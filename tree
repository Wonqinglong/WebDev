<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>决策树可视化</title>
<style>
  #upload-btn {
    margin-bottom: 10px;
  }
  #tree-container {
    font-family: monospace;
    overflow: hidden;
    white-space: nowrap;
    position: relative;
  }
  .node {
    position: relative;
    display: inline-block;
    padding: 10px;
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    border-radius: 5px;
    margin-right: 20px;
    transition: transform 0.3s ease;
  }
  .node.collapsed {
    transform: scale(0);
  }
  .branch-line {
    position: absolute;
    background-color: #ccc;
    width: 2px;
    top: 0;
    bottom: 0;
    left: calc(50% - 1px);
    z-index: -1;
    transition: transform 0.3s ease;
  }
  .branch-line.collapsed {
    transform: scaleY(0);
  }
</style>
</head>
<body>
<input type="file" id="file-input" accept=".csv">
<button id="upload-btn">上传文件</button>
<div id="tree-container"></div>

<script>
document.getElementById('upload-btn').addEventListener('click', function() {
  const fileInput = document.getElementById('file-input');
  const file = fileInput.files[0];
  if (!file) {
    alert('请选择一个CSV文件');
    return;
  }

  const reader = new FileReader();
  reader.onload = function(event) {
    const csvString = event.target.result;
    const { headers, data } = parseCSV(csvString);
    const decisionTree = buildDecisionTree(data, '结果', headers.slice(0, -1));
    displayTree(decisionTree, document.getElementById('tree-container'));
  };
  reader.readAsText(file);
});

// 解析CSV字符串为数据数组
function parseCSV(csvString) {
    const lines = csvString.split('\n');
    const headers = lines[0].split(',').map(header => header.trim());
    const data = [];

    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(value => parseFloat(value.trim()));
        const row = {};
        for (let j = 0; j < headers.length; j++) {
            row[headers[j]] = values[j];
        }
        data.push(row);
    }

    return { headers, data };
}

// 决策树节点类
class TreeNode {
    constructor(attribute, branches, result) {
        this.attribute = attribute; // 分裂属性
        this.branches = branches; // 子节点
        this.result = result; // 叶节点的结果
    }
}

// 计算数据集的熵
function calculateEntropy(data) {
    const counts = {};
    for (const row of data) {
        const result = row['结果'];
        counts[result] = (counts[result] || 0) + 1;
    }
    const totalCount = data.length;
    let entropy = 0;
    for (const count of Object.values(counts)) {
        const probability = count / totalCount;
        entropy -= probability * Math.log2(probability);
    }
    return entropy;
}

// 从数据集中选择最佳分裂属性
function chooseBestAttribute(data, attributes) {
    let bestAttribute = null;
    let bestInfoGain = -Infinity;
    const baseEntropy = calculateEntropy(data);
    for (const attribute of attributes) {
        const attributeValues = new Set(data.map(row => row[attribute]));
        let newEntropy = 0;
        for (const value of attributeValues) {
            const subset = data.filter(row => row[attribute] === value);
            const probability = subset.length / data.length;
            newEntropy += probability * calculateEntropy(subset);
        }
        const infoGain = baseEntropy - newEntropy;
        if (infoGain > bestInfoGain) {
            bestInfoGain = infoGain;
            bestAttribute = attribute;
        }
    }
    return bestAttribute;
}

// 构建决策树
function buildDecisionTree(data, targetAttribute, attributes) {
    if (data.length === 0) {
        return null;
    }
    const uniqueResults = [...new Set(data.map(row => row[targetAttribute]))];
    if (uniqueResults.length === 1) {
        return new TreeNode(null, null, uniqueResults[0]);
    }
    if (attributes.length === 0) {
        const majorityResult = getMajorityResult(data, targetAttribute);
        return new TreeNode(null, null, majorityResult);
    }
    const bestAttribute = chooseBestAttribute(data, attributes);
    const remainingAttributes = attributes.filter(attr => attr !== bestAttribute);
    const branches = {};
    const attributeValues = new Set(data.map(row => row[bestAttribute]));
    for (const value of attributeValues) {
        const subset = data.filter(row => row[bestAttribute] === value);
        branches[value] = buildDecisionTree(subset, targetAttribute, remainingAttributes);
    }
    return new TreeNode(bestAttribute, branches, null);
}

// 获取数据集中的主要结果
function getMajorityResult(data, targetAttribute) {
    const counts = {};
    for (const row of data) {
        const result = row[targetAttribute];
        counts[result] = (counts[result] || 0) + 1;
    }
    let maxCount = -Infinity;
    let majorityResult = null;
    for (const [result, count] of Object.entries(counts)) {
        if (count > maxCount) {
            maxCount = count;
            majorityResult = result;
        }
    }
    return majorityResult;
}

// 决策树可视化逻辑（树状图）
function displayTree(decisionTree, container, x = 0, y = 0) {
    if (decisionTree.result !== null) {
        drawNode(decisionTree.result, container, x, y);
    } else {
        drawNode(decisionTree.attribute, container, x, y);
        let branchX = x;
        for (const branch of Object.values(decisionTree.branches)) {
            const childX = branchX + 150;
            const childY = y + 100;
            drawBranch(container, x, y, childX, childY);
            displayTree(branch, container, childX, childY);
            branchX = childX;
        }
    }
}

// 绘制节点
function drawNode(text, container, x, y) {
    const node = document.createElement('div');
    node.classList.add('node');
    node.textContent = text;
    node.style.position = 'absolute';
    node.style.left = x + 'px';
    node.style.top = y + 'px';
    container.appendChild(node);
}

// 绘制分支连接线
function drawBranch(container, startX, startY, endX, endY) {
    const branchLine = document.createElement('div');
    branchLine.classList.add('branch-line');
    branchLine.style.position = 'absolute';
    branchLine.style.width = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)) + 'px';
    branchLine.style.height = '2px';
    branchLine.style.background = '#f00';
    branchLine.style.transformOrigin = '0 0';
    const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
    branchLine.style.transform = 'rotate(' + angle + 'deg)';
    branchLine.style.left = startX + 'px';
    branchLine.style.top = startY + 'px';
    container.appendChild(branchLine);
}
</script>
</body>
</html>